<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Spreadsheet</title>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <style>
        :root {
            --primary: #1a73e8;
            --primary-light: #e8f0fe;
            --secondary: #5f6368;
            --bg: #f8f9fa;
            --panel: #ffffff;
            --header: #f1f3f4;
            --border: #dadce0;
            --hover: #e8f0fe;
            --selected: #d2e3fc;
            --text: #202124;
            --text-light: #5f6368;
            --success: #34a853;
            --danger: #ea4335;
            --warning: #f9ab00;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
            gap: 10px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--panel);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: var(--primary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .logo-text h1 {
            font-size: 18px;
            font-weight: 600;
            color: var(--primary);
        }

        .logo-text .subtitle {
            font-size: 12px;
            color: var(--text-light);
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-light);
            font-size: 14px;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 15px;
            background: var(--panel);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .toolbar-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding-right: 10px;
            border-right: 1px solid var(--border);
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar button, .toolbar select {
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: white;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }

        .toolbar button:hover, .toolbar select:hover {
            background: var(--hover);
        }

        .toolbar button:active {
            background: var(--selected);
        }

        .toolbar button.active {
            background: var(--primary-light);
            color: var(--primary);
            border-color: var(--primary);
        }

        .toolbar input[type="color"] {
            width: 30px;
            height: 30px;
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
        }

        .toolbar label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            color: var(--text-light);
        }

        .formula-bar {
            display: flex;
            gap: 5px;
            padding: 5px 15px;
            background: var(--panel);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .cell-ref {
            width: 80px;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: monospace;
            text-align: center;
            background: var(--header);
        }

        .formula-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: monospace;
        }

        .sheet-container {
            flex: 1;
            overflow: auto;
            background: var(--panel);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: relative;
        }

        .sheet-wrapper {
            overflow: auto;
            height: 100%;
            position: relative;
        }

        table.sheet {
            border-collapse: collapse;
            table-layout: fixed;
            min-width: 100%;
        }

        table.sheet th, table.sheet td {
            border: 1px solid var(--border);
            padding: 4px 8px;
            min-width: 80px;
            max-width: 200px;
            height: 24px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            user-select: none;
        }

        table.sheet th {
            background: var(--header);
            position: sticky;
            z-index: 2;
            text-align: center;
            font-weight: 500;
            color: var(--text-light);
        }

        .col-header {
            top: 0;
        }

        .row-header {
            left: 0;
            z-index: 3;
        }

        .corner-header {
            top: 0;
            left: 0;
            z-index: 4;
            background: var(--header);
        }

        table.sheet td {
            background: white;
            outline: none;
            position: relative;
        }

        table.sheet td.selected {
            background: var(--selected);
        }

        table.sheet td.focused {
            outline: 2px solid var(--primary);
            z-index: 1;
        }

        .selection-rect {
            position: absolute;
            border: 2px solid var(--primary);
            background: rgba(26, 115, 232, 0.1);
            pointer-events: none;
            z-index: 1;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            background: var(--panel);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            font-size: 14px;
            color: var(--text-light);
        }

        .status-left, .status-right {
            display: flex;
            gap: 15px;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .zoom-controls button {
            width: 24px;
            height: 24px;
            border: 1px solid var(--border);
            background: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid var(--border);
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
            flex-direction: column;
            padding: 5px 0;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: var(--hover);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .toolbar-group {
                padding-right: 5px;
            }
            
            .toolbar button span, .toolbar select span {
                display: none;
            }
            
            .toolbar button, .toolbar select {
                padding: 6px;
            }
            
            .user-info .user-name {
                display: none;
            }
        }

        @media (max-width: 480px) {
            .toolbar-group:not(:first-child) {
                display: none;
            }
            
            .formula-bar {
                flex-direction: column;
            }
            
            .cell-ref {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <div class="logo">
                <div class="logo-icon">S</div>
                <div class="logo-text">
                    <h1>Spreadsheet Pro</h1>
                    <div class="subtitle">Advanced spreadsheet system</div>
                </div>
            </div>
            <div class="user-info">
                <span class="user-name">John Doe</span>
                <div class="user-avatar">JD</div>
            </div>
        </header>

        <div class="toolbar">
            <div class="toolbar-group">
                <button id="newBtn">
                    <span>New</span>
                </button>
                <button id="openBtn">
                    <span>Open</span>
                </button>
                <button id="saveBtn">
                    <span>Save</span>
                </button>
            </div>
            
            <div class="toolbar-group">
                <button id="undoBtn">
                    <span>Undo</span>
                </button>
                <button id="redoBtn">
                    <span>Redo</span>
                </button>
            </div>
            
            <div class="toolbar-group">
                <button id="cutBtn">
                    <span>Cut</span>
                </button>
                <button id="copyBtn">
                    <span>Copy</span>
                </button>
                <button id="pasteBtn">
                    <span>Paste</span>
                </button>
            </div>
            
            <div class="toolbar-group">
                <button id="boldBtn">
                    <span>Bold</span>
                </button>
                <button id="italicBtn">
                    <span>Italic</span>
                </button>
                <button id="underlineBtn">
                    <span>Underline</span>
                </button>
            </div>
            
            <div class="toolbar-group">
                <label>
                    <input type="color" id="textColor" value="#000000">
                    <span>Text</span>
                </label>
                <label>
                    <input type="color" id="bgColor" value="#ffffff">
                    <span>Fill</span>
                </label>
            </div>
            
            <div class="toolbar-group">
                <select id="fontSize">
                    <option value="10">10</option>
                    <option value="12" selected>12</option>
                    <option value="14">14</option>
                    <option value="16">16</option>
                    <option value="18">18</option>
                    <option value="20">20</option>
                </select>
                <select id="fontFamily">
                    <option value="Arial">Arial</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Verdana" selected>Verdana</option>
                </select>
            </div>
            
            <div class="toolbar-group">
                <button id="alignLeftBtn">
                    <span>Left</span>
                </button>
                <button id="alignCenterBtn">
                    <span>Center</span>
                </button>
                <button id="alignRightBtn">
                    <span>Right</span>
                </button>
            </div>
            
            <div class="toolbar-group">
                <button id="insertRowBtn">
                    <span>Insert Row</span>
                </button>
                <button id="insertColBtn">
                    <span>Insert Column</span>
                </button>
                <button id="deleteRowBtn">
                    <span>Delete Row</span>
                </button>
                <button id="deleteColBtn">
                    <span>Delete Column</span>
                </button>
            </div>
            
            <div class="toolbar-group">
                <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" style="display:none"/>
                <button id="importBtn">
                    <span>Import</span>
                </button>
                <button id="exportXlsxBtn">
                    <span>Export XLSX</span>
                </button>
                <button id="exportCsvBtn">
                    <span>Export CSV</span>
                </button>
            </div>
        </div>

        <div class="formula-bar">
            <div class="cell-ref" id="activeCell">A1</div>
            <input type="text" class="formula-input" id="formulaInput" placeholder="Enter formula or value">
        </div>

        <div class="sheet-container">
            <div class="sheet-wrapper" id="sheetWrapper">
                <div class="selection-rect" id="selectionRect"></div>
                <table class="sheet" id="sheetTable"></table>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-left">
                <span>Ready</span>
                <span id="selectionInfo">No selection</span>
            </div>
            <div class="status-right">
                <div class="zoom-controls">
                    <button id="zoomOutBtn">-</button>
                    <span id="zoomLevel">100%</span>
                    <button id="zoomInBtn">+</button>
                </div>
                <span id="cellCount">0 cells</span>
            </div>
        </div>

        <div class="context-menu" id="contextMenu">
            <div class="context-menu-item" data-action="cut">
                <span>Cut</span>
            </div>
            <div class="context-menu-item" data-action="copy">
                <span>Copy</span>
            </div>
            <div class="context-menu-item" data-action="paste">
                <span>Paste</span>
            </div>
            <div class="context-menu-divider"></div>
            <div class="context-menu-item" data-action="insertRow">
                <span>Insert Row</span>
            </div>
            <div class="context-menu-item" data-action="insertColumn">
                <span>Insert Column</span>
            </div>
            <div class="context-menu-divider"></div>
            <div class="context-menu-item" data-action="deleteRow">
                <span>Delete Row</span>
            </div>
            <div class="context-menu-item" data-action="deleteColumn">
                <span>Delete Column</span>
            </div>
        </div>
    </div>

    <script>
        // Constants and configuration
        const DEFAULT_ROWS = 50;
        const DEFAULT_COLS = 20;
        const MIN_ROWS = 10;
        const MIN_COLS = 5;
        const MAX_ROWS = 1000;
        const MAX_COLS = 100;

        // Global state
        let rows = DEFAULT_ROWS;
        let cols = DEFAULT_COLS;
        let undoStack = [];
        let redoStack = [];
        let clipboard = [];
        let selection = {
            start: null,
            end: null,
            isSelecting: false
        };
        let activeCell = null;
        let zoomLevel = 100;
        let cellData = {}; // Store cell data and formatting
        let isEditing = false;
        let editCell = null;

        // DOM elements
        const sheetWrapper = document.getElementById('sheetWrapper');
        const sheetTable = document.getElementById('sheetTable');
        const selectionRect = document.getElementById('selectionRect');
        const activeCellRef = document.getElementById('activeCell');
        const formulaInput = document.getElementById('formulaInput');
        const contextMenu = document.getElementById('contextMenu');
        const selectionInfo = document.getElementById('selectionInfo');
        const cellCount = document.getElementById('cellCount');
        const zoomLevelDisplay = document.getElementById('zoomLevel');

        // Helper functions
        function colToLetter(col) {
            let temp, letter = '';
            while (col > 0) {
                temp = (col - 1) % 26;
                letter = String.fromCharCode(temp + 65) + letter;
                col = (col - temp - 1) / 26;
            }
            return letter;
        }

        function letterToCol(letter) {
            let column = 0, length = letter.length;
            for (let i = 0; i < length; i++) {
                column += (letter.charCodeAt(i) - 64) * Math.pow(26, length - i - 1);
            }
            return column;
        }

        function getCellId(row, col) {
            return `${colToLetter(col)}${row}`;
        }

        function getCellFromId(id) {
            const match = id.match(/([A-Z]+)(\d+)/);
            if (!match) return null;
            return {
                row: parseInt(match[2]),
                col: letterToCol(match[1])
            };
        }

        // Initialize the spreadsheet
        function initSpreadsheet() {
            buildTable();
            setupEventListeners();
            updateStatusBar();
            
            // Set initial active cell
            const initialCell = document.querySelector('td[data-row="1"][data-col="1"]');
            if (initialCell) {
                setActiveCell(initialCell);
            }
        }

        // Build the spreadsheet table
        function buildTable() {
            sheetTable.innerHTML = '';
            
            // Create header row with column letters
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            // Corner cell (empty)
            const cornerCell = document.createElement('th');
            cornerCell.className = 'corner-header';
            headerRow.appendChild(cornerCell);
            
            // Column headers
            for (let col = 1; col <= cols; col++) {
                const th = document.createElement('th');
                th.className = 'col-header';
                th.textContent = colToLetter(col);
                th.dataset.col = col;
                headerRow.appendChild(th);
            }
            
            thead.appendChild(headerRow);
            sheetTable.appendChild(thead);
            
            // Create table body with rows and cells
            const tbody = document.createElement('tbody');
            
            for (let row = 1; row <= rows; row++) {
                const tr = document.createElement('tr');
                
                // Row header
                const rowHeader = document.createElement('th');
                rowHeader.className = 'row-header';
                rowHeader.textContent = row;
                rowHeader.dataset.row = row;
                tr.appendChild(rowHeader);
                
                // Data cells
                for (let col = 1; col <= cols; col++) {
                    const td = document.createElement('td');
                    td.dataset.row = row;
                    td.dataset.col = col;
                    td.dataset.id = getCellId(row, col);
                    
                    // Set content if we have data
                    const cellId = getCellId(row, col);
                    if (cellData[cellId]) {
                        td.textContent = cellData[cellId].value || '';
                        applyCellFormatting(td, cellData[cellId].formatting || {});
                    }
                    
                    tr.appendChild(td);
                }
                
                tbody.appendChild(tr);
            }
            
            sheetTable.appendChild(tbody);
        }

        // Apply formatting to a cell
        function applyCellFormatting(cell, formatting) {
            if (formatting.fontWeight === 'bold') {
                cell.style.fontWeight = 'bold';
            }
            
            if (formatting.fontStyle === 'italic') {
                cell.style.fontStyle = 'italic';
            }
            
            if (formatting.textDecoration === 'underline') {
                cell.style.textDecoration = 'underline';
            }
            
            if (formatting.color) {
                cell.style.color = formatting.color;
            }
            
            if (formatting.backgroundColor) {
                cell.style.backgroundColor = formatting.backgroundColor;
            }
            
            if (formatting.fontSize) {
                cell.style.fontSize = formatting.fontSize + 'px';
            }
            
            if (formatting.fontFamily) {
                cell.style.fontFamily = formatting.fontFamily;
            }
            
            if (formatting.textAlign) {
                cell.style.textAlign = formatting.textAlign;
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Cell selection events
            sheetTable.addEventListener('mousedown', handleMouseDown);
            sheetTable.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            // Keyboard events
            document.addEventListener('keydown', handleKeyDown);
            
            // Formula input
            formulaInput.addEventListener('input', handleFormulaInput);
            formulaInput.addEventListener('blur', handleFormulaBlur);
            
            // Context menu
            document.addEventListener('contextmenu', handleContextMenu);
            document.addEventListener('click', () => {
                contextMenu.style.display = 'none';
            });
            
            // Context menu actions
            contextMenu.querySelectorAll('.context-menu-item').forEach(item => {
                item.addEventListener('click', handleContextMenuAction);
            });
            
            // Toolbar buttons
            document.getElementById('newBtn').addEventListener('click', newSpreadsheet);
            document.getElementById('saveBtn').addEventListener('click', saveSpreadsheet);
            document.getElementById('openBtn').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            
            document.getElementById('cutBtn').addEventListener('click', cutCells);
            document.getElementById('copyBtn').addEventListener('click', copyCells);
            document.getElementById('pasteBtn').addEventListener('click', pasteCells);
            
            document.getElementById('boldBtn').addEventListener('click', () => toggleFormatting('fontWeight', 'bold'));
            document.getElementById('italicBtn').addEventListener('click', () => toggleFormatting('fontStyle', 'italic'));
            document.getElementById('underlineBtn').addEventListener('click', () => toggleFormatting('textDecoration', 'underline'));
            
            document.getElementById('textColor').addEventListener('input', (e) => applyFormattingToSelection('color', e.target.value));
            document.getElementById('bgColor').addEventListener('input', (e) => applyFormattingToSelection('backgroundColor', e.target.value));
            
            document.getElementById('fontSize').addEventListener('change', (e) => applyFormattingToSelection('fontSize', e.target.value));
            document.getElementById('fontFamily').addEventListener('change', (e) => applyFormattingToSelection('fontFamily', e.target.value));
            
            document.getElementById('alignLeftBtn').addEventListener('click', () => applyFormattingToSelection('textAlign', 'left'));
            document.getElementById('alignCenterBtn').addEventListener('click', () => applyFormattingToSelection('textAlign', 'center'));
            document.getElementById('alignRightBtn').addEventListener('click', () => applyFormattingToSelection('textAlign', 'right'));
            
            document.getElementById('insertRowBtn').addEventListener('click', insertRow);
            document.getElementById('insertColBtn').addEventListener('click', insertColumn);
            document.getElementById('deleteRowBtn').addEventListener('click', deleteRow);
            document.getElementById('deleteColBtn').addEventListener('click', deleteColumn);
            
            document.getElementById('importBtn').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            document.getElementById('fileInput').addEventListener('change', handleFileImport);
            
            document.getElementById('exportXlsxBtn').addEventListener('click', exportToXlsx);
            document.getElementById('exportCsvBtn').addEventListener('click', exportToCsv);
            
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            
            // Column and row header selection
            sheetTable.addEventListener('click', handleHeaderClick);
            
            // Direct cell editing
            sheetTable.addEventListener('dblclick', handleDoubleClick);
        }

        // Selection handling
        function handleMouseDown(e) {
            const cell = e.target.closest('td');
            if (!cell) return;
            
            e.preventDefault();
            
            // Clear previous selection
            clearSelection();
            
            // Set active cell
            setActiveCell(cell);
            
            // Start selection
            selection.start = {
                row: parseInt(cell.dataset.row),
                col: parseInt(cell.dataset.col)
            };
            selection.end = { ...selection.start };
            selection.isSelecting = true;
            
            updateSelectionRect();
            updateStatusBar();
        }

        function handleMouseMove(e) {
            if (!selection.isSelecting) return;
            
            const cell = e.target.closest('td');
            if (!cell) return;
            
            selection.end = {
                row: parseInt(cell.dataset.row),
                col: parseInt(cell.dataset.col)
            };
            
            updateSelectionRect();
            updateStatusBar();
        }

        function handleMouseUp() {
            selection.isSelecting = false;
        }

        function handleHeaderClick(e) {
            const th = e.target.closest('th');
            if (!th) return;
            
            clearSelection();
            
            if (th.classList.contains('col-header')) {
                const col = parseInt(th.dataset.col);
                selectColumn(col);
            } else if (th.classList.contains('row-header')) {
                const row = parseInt(th.dataset.row);
                selectRow(row);
            }
            
            updateStatusBar();
        }

        function selectColumn(col) {
            selection.start = { row: 1, col };
            selection.end = { row: rows, col };
            
            highlightSelectedCells();
            updateSelectionRect();
        }

        function selectRow(row) {
            selection.start = { row, col: 1 };
            selection.end = { row, col: cols };
            
            highlightSelectedCells();
            updateSelectionRect();
        }

        function clearSelection() {
            document.querySelectorAll('.selected').forEach(cell => {
                cell.classList.remove('selected');
            });
            
            selectionRect.style.display = 'none';
        }

        function highlightSelectedCells() {
            clearSelection();
            
            const startRow = Math.min(selection.start.row, selection.end.row);
            const endRow = Math.max(selection.start.row, selection.end.row);
            const startCol = Math.min(selection.start.col, selection.end.col);
            const endCol = Math.max(selection.start.col, selection.end.col);
            
            for (let row = startRow; row <= endRow; row++) {
                for (let col = startCol; col <= endCol; col++) {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) {
                        cell.classList.add('selected');
                    }
                }
            }
        }

        function updateSelectionRect() {
            if (!selection.start || !selection.end) return;
            
            const startCell = document.querySelector(`td[data-row="${selection.start.row}"][data-col="${selection.start.col}"]`);
            const endCell = document.querySelector(`td[data-row="${selection.end.row}"][data-col="${selection.end.col}"]`);
            
            if (!startCell || !endCell) return;
            
            const startRect = startCell.getBoundingClientRect();
            const endRect = endCell.getBoundingClientRect();
            const wrapperRect = sheetWrapper.getBoundingClientRect();
            
            const left = Math.min(startRect.left, endRect.left) - wrapperRect.left + sheetWrapper.scrollLeft;
            const top = Math.min(startRect.top, endRect.top) - wrapperRect.top + sheetWrapper.scrollTop;
            const width = Math.abs(endRect.left - startRect.left) + endCell.offsetWidth;
            const height = Math.abs(endRect.bottom - startRect.top) + endCell.offsetHeight;
            
            selectionRect.style.left = `${left}px`;
            selectionRect.style.top = `${top}px`;
            selectionRect.style.width = `${width}px`;
            selectionRect.style.height = `${height}px`;
            selectionRect.style.display = 'block';
            
            highlightSelectedCells();
        }

        function setActiveCell(cell) {
            if (activeCell) {
                activeCell.classList.remove('focused');
            }
            
            activeCell = cell;
            activeCell.classList.add('focused');
            activeCellRef.textContent = cell.dataset.id;
            
            const cellId = cell.dataset.id;
            if (cellData[cellId]) {
                formulaInput.value = cellData[cellId].value || '';
            } else {
                formulaInput.value = cell.textContent || '';
            }
        }

        // Keyboard handling
        function handleKeyDown(e) {
            if (!activeCell) return;
            
            const row = parseInt(activeCell.dataset.row);
            const col = parseInt(activeCell.dataset.col);
            
            // Direct editing - if a printable key is pressed and we're not already editing
            if (!isEditing && e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                e.preventDefault();
                startDirectEditing(activeCell, e.key);
                return;
            }
            
            // Navigation keys
            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    if (row > 1) navigateToCell(row - 1, col);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (row < rows) navigateToCell(row + 1, col);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (col > 1) navigateToCell(row, col - 1);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (col < cols) navigateToCell(row, col + 1);
                    break;
                case 'Tab':
                    e.preventDefault();
                    if (e.shiftKey) {
                        if (col > 1) navigateToCell(row, col - 1);
                    } else {
                        if (col < cols) navigateToCell(row, col + 1);
                    }
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (isEditing) {
                        finishEditing();
                        if (e.shiftKey) {
                            if (row > 1) navigateToCell(row - 1, col);
                        } else {
                            if (row < rows) navigateToCell(row + 1, col);
                        }
                    } else {
                        startDirectEditing(activeCell, '');
                    }
                    break;
                case 'Escape':
                    if (isEditing) {
                        e.preventDefault();
                        cancelEditing();
                    }
                    break;
                case 'Delete':
                case 'Backspace':
                    e.preventDefault();
                    clearSelectedCells();
                    break;
                // Copy/Paste
                case 'c':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        copyCells();
                    }
                    break;
                case 'x':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        cutCells();
                    }
                    break;
                case 'v':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        pasteCells();
                    }
                    break;
                case 'z':
                    if ((e.ctrlKey || e.metaKey) && !e.shiftKey) {
                        e.preventDefault();
                        undo();
                    }
                    break;
                case 'y':
                    if ((e.ctrlKey || e.metaKey) || (e.ctrlKey && e.shiftKey)) {
                        e.preventDefault();
                        redo();
                    }
                    break;
            }
        }

        // Direct cell editing
        function startDirectEditing(cell, initialChar = '') {
            if (isEditing) return;
            
            isEditing = true;
            editCell = cell;
            
            // Create input element
            const input = document.createElement('input');
            input.type = 'text';
            input.value = initialChar;
            input.style.position = 'absolute';
            input.style.left = cell.offsetLeft + 'px';
            input.style.top = cell.offsetTop + 'px';
            input.style.width = cell.offsetWidth + 'px';
            input.style.height = cell.offsetHeight + 'px';
            input.style.border = '2px solid var(--primary)';
            input.style.padding = '2px 4px';
            input.style.fontSize = 'inherit';
            input.style.fontFamily = 'inherit';
            input.style.backgroundColor = 'white';
            input.style.zIndex = '10';
            
            // Position relative to sheet wrapper
            const wrapperRect = sheetWrapper.getBoundingClientRect();
            const cellRect = cell.getBoundingClientRect();
            input.style.left = (cellRect.left - wrapperRect.left + sheetWrapper.scrollLeft) + 'px';
            input.style.top = (cellRect.top - wrapperRect.top + sheetWrapper.scrollTop) + 'px';
            
            sheetWrapper.appendChild(input);
            input.focus();
            input.select();
            
            // Handle input events
            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEditing();
                    
                    // Move to next cell
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    if (row < rows) {
                        navigateToCell(row + 1, col);
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEditing();
                }
            });
            
            // Update formula input
            formulaInput.value = initialChar;
        }

        function finishEditing() {
            if (!isEditing || !editCell) return;
            
            const input = sheetWrapper.querySelector('input');
            if (!input) return;
            
            const value = input.value;
            const cellId = editCell.dataset.id;
            
            // Save previous value for undo
            const prevValue = cellData[cellId] ? cellData[cellId].value : '';
            
            // Update cell
            editCell.textContent = value;
            if (!cellData[cellId]) {
                cellData[cellId] = { value: '', formatting: {} };
            }
            cellData[cellId].value = value;
            
            // Update formula input
            formulaInput.value = value;
            
            // Save to undo stack if value changed
            if (prevValue !== value) {
                saveToUndoStack({
                    type: 'cellEdit',
                    cellId,
                    prevValue,
                    newValue: value
                });
            }
            
            // Clean up
            sheetWrapper.removeChild(input);
            isEditing = false;
            editCell = null;
            
            updateStatusBar();
        }

        function cancelEditing() {
            if (!isEditing || !editCell) return;
            
            const input = sheetWrapper.querySelector('input');
            if (!input) return;
            
            // Restore original value in formula input
            const cellId = editCell.dataset.id;
            if (cellData[cellId]) {
                formulaInput.value = cellData[cellId].value || '';
            } else {
                formulaInput.value = editCell.textContent || '';
            }
            
            // Clean up
            sheetWrapper.removeChild(input);
            isEditing = false;
            editCell = null;
        }

        function handleDoubleClick(e) {
            const cell = e.target.closest('td');
            if (!cell) return;
            
            setActiveCell(cell);
            startDirectEditing(cell, cell.textContent);
        }

        function navigateToCell(row, col) {
            const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
            if (cell) {
                setActiveCell(cell);
                
                // Update selection to single cell
                selection.start = { row, col };
                selection.end = { row, col };
                updateSelectionRect();
                updateStatusBar();
                
                // Ensure cell is visible
                cell.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
        }

        // Formula handling
        function handleFormulaInput() {
            if (activeCell && !isEditing) {
                activeCell.textContent = formulaInput.value;
                
                const cellId = activeCell.dataset.id;
                if (!cellData[cellId]) {
                    cellData[cellId] = { value: '', formatting: {} };
                }
                cellData[cellId].value = formulaInput.value;
            }
        }

        function handleFormulaBlur() {
            // Save to undo stack when formula input loses focus
            if (activeCell && !isEditing) {
                const cellId = activeCell.dataset.id;
                const prevValue = cellData[cellId] ? cellData[cellId].value : '';
                const newValue = formulaInput.value;
                
                if (prevValue !== newValue) {
                    saveToUndoStack({
                        type: 'cellEdit',
                        cellId,
                        prevValue,
                        newValue
                    });
                }
            }
        }

        // Context menu
        function handleContextMenu(e) {
            e.preventDefault();
            
            const cell = e.target.closest('td');
            if (cell) {
                setActiveCell(cell);
                
                // Update selection to single cell
                selection.start = {
                    row: parseInt(cell.dataset.row),
                    col: parseInt(cell.dataset.col)
                };
                selection.end = { ...selection.start };
                updateSelectionRect();
            }
            
            contextMenu.style.display = 'flex';
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
        }

        function handleContextMenuAction(e) {
            const action = e.currentTarget.dataset.action;
            
            switch (action) {
                case 'cut':
                    cutCells();
                    break;
                case 'copy':
                    copyCells();
                    break;
                case 'paste':
                    pasteCells();
                    break;
                case 'insertRow':
                    insertRow();
                    break;
                case 'insertColumn':
                    insertColumn();
                    break;
                case 'deleteRow':
                    deleteRow();
                    break;
                case 'deleteColumn':
                    deleteColumn();
                    break;
            }
            
            contextMenu.style.display = 'none';
        }

        // Clipboard operations
        function copyCells() {
            if (!selection.start || !selection.end) return;
            
            clipboard = [];
            
            const startRow = Math.min(selection.start.row, selection.end.row);
            const endRow = Math.max(selection.start.row, selection.end.row);
            const startCol = Math.min(selection.start.col, selection.end.col);
            const endCol = Math.max(selection.start.col, selection.end.col);
            
            for (let row = startRow; row <= endRow; row++) {
                const rowData = [];
                for (let col = startCol; col <= endCol; col++) {
                    const cellId = getCellId(row, col);
                    if (cellData[cellId]) {
                        rowData.push({
                            value: cellData[cellId].value,
                            formatting: { ...cellData[cellId].formatting }
                        });
                    } else {
                        rowData.push({ value: '', formatting: {} });
                    }
                }
                clipboard.push(rowData);
            }
        }

        function cutCells() {
            copyCells();
            clearSelectedCells();
        }

        function pasteCells() {
            if (!clipboard.length || !selection.start) return;
            
            const startRow = selection.start.row;
            const startCol = selection.start.col;
            
            // Save state for undo
            const prevState = [];
            
            for (let i = 0; i < clipboard.length; i++) {
                for (let j = 0; j < clipboard[i].length; j++) {
                    const row = startRow + i;
                    const col = startCol + j;
                    
                    if (row > rows || col > cols) continue;
                    
                    const cellId = getCellId(row, col);
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    
                    if (cell) {
                        // Save previous state
                        prevState.push({
                            cellId,
                            value: cellData[cellId] ? cellData[cellId].value : '',
                            formatting: cellData[cellId] ? { ...cellData[cellId].formatting } : {}
                        });
                        
                        // Update cell
                        const clipboardCell = clipboard[i][j];
                        cell.textContent = clipboardCell.value;
                        cellData[cellId] = {
                            value: clipboardCell.value,
                            formatting: { ...clipboardCell.formatting }
                        };
                        
                        applyCellFormatting(cell, clipboardCell.formatting);
                    }
                }
            }
            
            // Save to undo stack
            saveToUndoStack({
                type: 'paste',
                prevState,
                clipboard: clipboard
            });
            
            updateStatusBar();
        }

        function clearSelectedCells() {
            if (!selection.start || !selection.end) return;
            
            const startRow = Math.min(selection.start.row, selection.end.row);
            const endRow = Math.max(selection.start.row, selection.end.row);
            const startCol = Math.min(selection.start.col, selection.end.col);
            const endCol = Math.max(selection.start.col, selection.end.col);
            
            // Save state for undo
            const prevState = [];
            
            for (let row = startRow; row <= endRow; row++) {
                for (let col = startCol; col <= endCol; col++) {
                    const cellId = getCellId(row, col);
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    
                    if (cell) {
                        // Save previous state
                        prevState.push({
                            cellId,
                            value: cellData[cellId] ? cellData[cellId].value : '',
                            formatting: cellData[cellId] ? { ...cellData[cellId].formatting } : {}
                        });
                        
                        // Clear cell
                        cell.textContent = '';
                        if (cellData[cellId]) {
                            cellData[cellId].value = '';
                        }
                    }
                }
            }
            
            // Save to undo stack
            saveToUndoStack({
                type: 'clear',
                prevState
            });
        }

        // Formatting functions
        function toggleFormatting(property, value) {
            if (!selection.start || !selection.end) return;
            
            const startRow = Math.min(selection.start.row, selection.end.row);
            const endRow = Math.max(selection.start.row, selection.end.row);
            const startCol = Math.min(selection.start.col, selection.end.col);
            const endCol = Math.max(selection.start.col, selection.end.col);
            
            // Save state for undo
            const prevState = [];
            
            for (let row = startRow; row <= endRow; row++) {
                for (let col = startCol; col <= endCol; col++) {
                    const cellId = getCellId(row, col);
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    
                    if (cell) {
                        // Save previous state
                        prevState.push({
                            cellId,
                            value: cellData[cellId] ? cellData[cellId].value : '',
                            formatting: cellData[cellId] ? { ...cellData[cellId].formatting } : {}
                        });
                        
                        // Initialize cell data if needed
                        if (!cellData[cellId]) {
                            cellData[cellId] = { value: cell.textContent || '', formatting: {} };
                        }
                        
                        // Toggle formatting
                        const currentValue = cellData[cellId].formatting[property];
                        if (currentValue === value) {
                            // Remove formatting
                            cellData[cellId].formatting[property] = '';
                            cell.style[property] = '';
                        } else {
                            // Apply formatting
                            cellData[cellId].formatting[property] = value;
                            cell.style[property] = value;
                        }
                    }
                }
            }
            
            // Save to undo stack
            saveToUndoStack({
                type: 'formatting',
                property,
                value,
                prevState
            });
        }

        function applyFormattingToSelection(property, value) {
            if (!selection.start || !selection.end) return;
            
            const startRow = Math.min(selection.start.row, selection.end.row);
            const endRow = Math.max(selection.start.row, selection.end.row);
            const startCol = Math.min(selection.start.col, selection.end.col);
            const endCol = Math.max(selection.start.col, selection.end.col);
            
            // Save state for undo
            const prevState = [];
            
            for (let row = startRow; row <= endRow; row++) {
                for (let col = startCol; col <= endCol; col++) {
                    const cellId = getCellId(row, col);
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    
                    if (cell) {
                        // Save previous state
                        prevState.push({
                            cellId,
                            value: cellData[cellId] ? cellData[cellId].value : '',
                            formatting: cellData[cellId] ? { ...cellData[cellId].formatting } : {}
                        });
                        
                        // Initialize cell data if needed
                        if (!cellData[cellId]) {
                            cellData[cellId] = { value: cell.textContent || '', formatting: {} };
                        }
                        
                        // Apply formatting
                        cellData[cellId].formatting[property] = value;
                        cell.style[property] = value;
                    }
                }
            }
            
            // Save to undo stack
            saveToUndoStack({
                type: 'formatting',
                property,
                value,
                prevState
            });
        }

        // Row and column operations
        function insertRow() {
            // Find the row to insert after (use selection or active cell)
            let insertAfter = 1;
            if (selection.start) {
                insertAfter = Math.min(selection.start.row, selection.end.row);
            } else if (activeCell) {
                insertAfter = parseInt(activeCell.dataset.row);
            }
            
            if (rows >= MAX_ROWS) return;
            
            rows++;
            
            // Save state for undo
            const prevState = { rows: rows - 1, cols, cellData: { ...cellData } };
            
            // Update cell data - shift rows down
            const newCellData = {};
            Object.keys(cellData).forEach(cellId => {
                const cell = getCellFromId(cellId);
                if (cell.row > insertAfter) {
                    newCellData[getCellId(cell.row + 1, cell.col)] = cellData[cellId];
                } else {
                    newCellData[cellId] = cellData[cellId];
                }
            });
            
            cellData = newCellData;
            buildTable();
            
            // Save to undo stack
            saveToUndoStack({
                type: 'insertRow',
                insertAfter,
                prevState
            });
            
            updateStatusBar();
        }

        function insertColumn() {
            // Find the column to insert after (use selection or active cell)
            let insertAfter = 1;
            if (selection.start) {
                insertAfter = Math.min(selection.start.col, selection.end.col);
            } else if (activeCell) {
                insertAfter = parseInt(activeCell.dataset.col);
            }
            
            if (cols >= MAX_COLS) return;
            
            cols++;
            
            // Save state for undo
            const prevState = { rows, cols: cols - 1, cellData: { ...cellData } };
            
            // Update cell data - shift columns right
            const newCellData = {};
            Object.keys(cellData).forEach(cellId => {
                const cell = getCellFromId(cellId);
                if (cell.col > insertAfter) {
                    newCellData[getCellId(cell.row, cell.col + 1)] = cellData[cellId];
                } else {
                    newCellData[cellId] = cellData[cellId];
                }
            });
            
            cellData = newCellData;
            buildTable();
            
            // Save to undo stack
            saveToUndoStack({
                type: 'insertColumn',
                insertAfter,
                prevState
            });
            
            updateStatusBar();
        }

        function deleteRow() {
            if (rows <= MIN_ROWS) return;
            
            // Find the row to delete (use selection or active cell)
            let deleteRow = 1;
            if (selection.start) {
                deleteRow = Math.min(selection.start.row, selection.end.row);
            } else if (activeCell) {
                deleteRow = parseInt(activeCell.dataset.row);
            }
            
            // Save state for undo
            const prevState = { rows, cols, cellData: { ...cellData } };
            
            // Update cell data - shift rows up
            const newCellData = {};
            Object.keys(cellData).forEach(cellId => {
                const cell = getCellFromId(cellId);
                if (cell.row < deleteRow) {
                    newCellData[cellId] = cellData[cellId];
                } else if (cell.row > deleteRow) {
                    newCellData[getCellId(cell.row - 1, cell.col)] = cellData[cellId];
                }
                // Row to delete is skipped
            });
            
            rows--;
            cellData = newCellData;
            buildTable();
            
            // Save to undo stack
            saveToUndoStack({
                type: 'deleteRow',
                deleteRow,
                prevState
            });
            
            updateStatusBar();
        }

        function deleteColumn() {
            if (cols <= MIN_COLS) return;
            
            // Find the column to delete (use selection or active cell)
            let deleteCol = 1;
            if (selection.start) {
                deleteCol = Math.min(selection.start.col, selection.end.col);
            } else if (activeCell) {
                deleteCol = parseInt(activeCell.dataset.col);
            }
            
            // Save state for undo
            const prevState = { rows, cols, cellData: { ...cellData } };
            
            // Update cell data - shift columns left
            const newCellData = {};
            Object.keys(cellData).forEach(cellId => {
                const cell = getCellFromId(cellId);
                if (cell.col < deleteCol) {
                    newCellData[cellId] = cellData[cellId];
                } else if (cell.col > deleteCol) {
                    newCellData[getCellId(cell.row, cell.col - 1)] = cellData[cellId];
                }
                // Column to delete is skipped
            });
            
            cols--;
            cellData = newCellData;
            buildTable();
            
            // Save to undo stack
            saveToUndoStack({
                type: 'deleteColumn',
                deleteCol,
                prevState
            });
            
            updateStatusBar();
        }

        // Undo/Redo functionality
        function saveToUndoStack(action) {
            undoStack.push(action);
            redoStack = []; // Clear redo stack when new action is performed
        }

        function undo() {
            if (undoStack.length === 0) return;
            
            const action = undoStack.pop();
            redoStack.push(action);
            
            applyUndoRedo(action, true);
        }

        function redo() {
            if (redoStack.length === 0) return;
            
            const action = redoStack.pop();
            undoStack.push(action);
            
            applyUndoRedo(action, false);
        }

        function applyUndoRedo(action, isUndo) {
            switch (action.type) {
                case 'cellEdit':
                    const cell = document.querySelector(`td[data-id="${action.cellId}"]`);
                    if (cell) {
                        const value = isUndo ? action.prevValue : action.newValue;
                        cell.textContent = value;
                        
                        if (!cellData[action.cellId]) {
                            cellData[action.cellId] = { value: '', formatting: {} };
                        }
                        cellData[action.cellId].value = value;
                        
                        if (activeCell && activeCell.dataset.id === action.cellId) {
                            formulaInput.value = value;
                        }
                    }
                    break;
                    
                case 'paste':
                case 'clear':
                case 'formatting':
                    const state = isUndo ? action.prevState : 
                        (action.type === 'paste' ? 
                            action.clipboard.flatMap((row, i) => 
                                row.map((cell, j) => ({
                                    cellId: getCellId(selection.start.row + i, selection.start.col + j),
                                    value: cell.value,
                                    formatting: cell.formatting
                                }))
                            ) : []);
                    
                    state.forEach(item => {
                        const cell = document.querySelector(`td[data-id="${item.cellId}"]`);
                        if (cell) {
                            cell.textContent = item.value;
                            cellData[item.cellId] = {
                                value: item.value,
                                formatting: { ...item.formatting }
                            };
                            applyCellFormatting(cell, item.formatting);
                        }
                    });
                    break;
                    
                case 'insertRow':
                case 'insertColumn':
                case 'deleteRow':
                case 'deleteColumn':
                    const prevState = isUndo ? action.prevState : 
                        { rows, cols, cellData: { ...cellData } };
                    
                    rows = prevState.rows;
                    cols = prevState.cols;
                    cellData = { ...prevState.cellData };
                    buildTable();
                    break;
            }
            
            updateStatusBar();
        }

        // File operations
        function newSpreadsheet() {
            if (confirm('Are you sure you want to create a new spreadsheet? Any unsaved changes will be lost.')) {
                rows = DEFAULT_ROWS;
                cols = DEFAULT_COLS;
                cellData = {};
                undoStack = [];
                redoStack = [];
                selection = { start: null, end: null, isSelecting: false };
                activeCell = null;
                
                buildTable();
                updateStatusBar();
                
                formulaInput.value = '';
                activeCellRef.textContent = 'A1';
                
                // Set initial active cell
                const initialCell = document.querySelector('td[data-row="1"][data-col="1"]');
                if (initialCell) {
                    setActiveCell(initialCell);
                }
            }
        }

        function saveSpreadsheet() {
            // In a real application, this would save to a server or local storage
            alert('Spreadsheet saved successfully!');
        }

        function handleFileImport(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    // Clear existing data
                    cellData = {};
                    
                    // Determine dimensions
                    rows = jsonData.length;
                    cols = Math.max(...jsonData.map(row => row.length));
                    
                    // Import data
                    jsonData.forEach((row, rowIndex) => {
                        row.forEach((cell, colIndex) => {
                            if (cell !== null && cell !== undefined) {
                                const cellId = getCellId(rowIndex + 1, colIndex + 1);
                                cellData[cellId] = {
                                    value: cell.toString(),
                                    formatting: {}
                                };
                            }
                        });
                    });
                    
                    buildTable();
                    updateStatusBar();
                    
                    // Set initial active cell
                    const initialCell = document.querySelector('td[data-row="1"][data-col="1"]');
                    if (initialCell) {
                        setActiveCell(initialCell);
                    }
                    
                    alert('File imported successfully!');
                } catch (error) {
                    alert('Error importing file: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
            
            // Reset file input
            e.target.value = '';
        }

        function exportToXlsx() {
            // Convert cell data to 2D array
            const data = [];
            for (let row = 1; row <= rows; row++) {
                const rowData = [];
                for (let col = 1; col <= cols; col++) {
                    const cellId = getCellId(row, col);
                    rowData.push(cellData[cellId] ? cellData[cellId].value : '');
                }
                data.push(rowData);
            }
            
            const worksheet = XLSX.utils.aoa_to_sheet(data);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');
            XLSX.writeFile(workbook, 'spreadsheet.xlsx');
        }

        function exportToCsv() {
            // Convert cell data to CSV
            let csv = '';
            for (let row = 1; row <= rows; row++) {
                const rowData = [];
                for (let col = 1; col <= cols; col++) {
                    const cellId = getCellId(row, col);
                    const value = cellData[cellId] ? cellData[cellId].value : '';
                    // Escape quotes and wrap in quotes if contains comma
                    if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                        rowData.push('"' + value.replace(/"/g, '""') + '"');
                    } else {
                        rowData.push(value);
                    }
                }
                csv += rowData.join(',') + '\n';
            }
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'spreadsheet.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Zoom functionality
        function zoomIn() {
            if (zoomLevel < 200) {
                zoomLevel += 10;
                applyZoom();
            }
        }

        function zoomOut() {
            if (zoomLevel > 50) {
                zoomLevel -= 10;
                applyZoom();
            }
        }

        function applyZoom() {
            const zoomFactor = zoomLevel / 100;
            sheetTable.style.transform = `scale(${zoomFactor})`;
            sheetTable.style.transformOrigin = '0 0';
            zoomLevelDisplay.textContent = `${zoomLevel}%`;
        }

        // Status bar updates
        function updateStatusBar() {
            // Update selection info
            if (selection.start && selection.end) {
                const startRow = Math.min(selection.start.row, selection.end.row);
                const endRow = Math.max(selection.start.row, selection.end.row);
                const startCol = Math.min(selection.start.col, selection.end.col);
                const endCol = Math.max(selection.start.col, selection.end.col);
                
                if (startRow === endRow && startCol === endCol) {
                    selectionInfo.textContent = `Cell: ${getCellId(startRow, startCol)}`;
                } else {
                    selectionInfo.textContent = 
                        `Selection: ${getCellId(startRow, startCol)}:${getCellId(endRow, endCol)}`;
                }
                
                // Update cell count
                const selectedCells = (endRow - startRow + 1) * (endCol - startCol + 1);
                cellCount.textContent = `${selectedCells} cells`;
            } else {
                selectionInfo.textContent = 'No selection';
                cellCount.textContent = '0 cells';
            }
        }

        // Initialize the spreadsheet when the page loads
        window.addEventListener('load', initSpreadsheet);
    </script>
</body>
</html>